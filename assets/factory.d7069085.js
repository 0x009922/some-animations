import{C as e,I as t,i as a,M as s,l as r,m as i,b as o,S as n,P as c,W as h,c as l,T as d,Q as p}from"./three.7b25054d.js";import{r as m,t as u}from"./index.6898e09e.js";import{c as f}from"./tools.f4cfa2c9.js";import"./index.0851d2b1.js";const{Vector3:g}=d,w={detail:4,icosahedronRadius:3,maxShift:1.5,faceScale:.9,lights:[{value:new e(14100024),position:new g(.5,.2,-.4)},{value:new e(65280),position:new g(-.5,0,-.4)},{value:new e(16723660),position:new g(0,-.5,0)},{value:new e(94137),position:new g(0,.4,.5)}],lightsRange:[2.5,2.7],defaultColor:new e(0),camYSpeed:2*Math.PI*.0132,camXSpeed:2*Math.PI*.003,camStartElapsed:m(100)};class y{constructor(e){this.faces=[],this.source=[],this.elapsed=0,this.geometry=new t(w.icosahedronRadius,w.detail),this.geometry.setAttribute("color",new a(new Array(this.geometry.attributes.position.array.length).fill(0),3));const l=new s({side:r,vertexColors:i}),d=new o(this.geometry,l);this.scene=new n,this.camera=new c(65,1,.1,1e3),this.renderer=new h({canvas:e,antialias:!0}),this.scene.add(d),this.prepareFaces(),this.skew(),this.computeColors(),this.updateLook()}animate(e){this.elapsed+=.001*e,this.updateLook(),this.render()}render(){this.renderer.render(this.scene,this.camera)}updateLook(){const e=this.elapsed+w.camStartElapsed,t=-e*w.camYSpeed,a=e*w.camXSpeed,s=new g(Math.cos(t),0,Math.sin(t)),r=new g(0,Math.sin(a),Math.cos(a)),i=new p;i.setFromAxisAngle(r,Math.PI/2),s.applyQuaternion(i).multiplyScalar(2),this.camera.rotation.y=-t,this.camera.rotation.x=-a,this.camera.position.set(...s.toArray())}prepareFaces(){this.faces=[];const e=this.geometry.attributes.position.array;for(let t=0;t<e.length;t+=9){const a=[new l(...e.slice(t,t+3)),new l(...e.slice(t+3,t+6)),new l(...e.slice(t+6,t+9))],s=new l;s.add(a[0]),s.add(a[1]),s.add(a[2]),s.divideScalar(3),a.forEach(((a,r)=>{{const e=new g(...s.toArray());e.sub(a),e.multiplyScalar(1-w.faceScale),a.add(e)}a.toArray().forEach(((a,s)=>{e[t+3*r+s]=a}))})),this.faces.push({center:s,direction:new g(...s.toArray()).divideScalar(s.length())})}this.source=[...e],this.geometry.attributes.position.needsUpdate=!0}skew(){this.faces.forEach((({direction:e},t)=>{const a=m(w.maxShift),s=e.toArray().map((e=>e*a)),{array:r}=this.geometry.attributes.position;for(let i=9*t;i<9*t+9;i++)r[i]=this.source[i]+s[i%3]})),this.geometry.attributes.position.needsUpdate=!0}computeColors(){const{array:e}=this.geometry.attributes.color;function t(e,t){const a=e.position,s=new g(a.x-t.x,a.y-t.y,a.z-t.z).length();if(s<=w.lightsRange[0])return e.value.toArray();if(s>=w.lightsRange[1])return w.defaultColor.toArray();let r=s-w.lightsRange[0];return r/=w.lightsRange[1]-w.lightsRange[0],["r","g","b"].map((t=>u(e.value[t],w.defaultColor[t],r)))}this.faces.forEach((({center:a},s)=>{const r=[0,0,0];for(const e of w.lights)t(e,a).forEach(((e,t)=>{r[t]+=e}));for(let t=0;t<9;t++)e[9*s+t]=r[t%3]/3})),this.geometry.attributes.color.needsUpdate=!0}}export default e=>{const t=new y(e);return{animate(e,a){t.animate(e,a)},setSize:f({render:()=>t.render(),renderer:t.renderer,camera:t.camera})}};
