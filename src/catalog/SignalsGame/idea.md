# Signals Game

Игра сигналами. Построение систем, в которых воспроизводимы логические элементы. Идея от редстоуна в майнкрафте.

## компоненты

### сетка

Сетка из квадратов, на которой будут располагаться элементы. Пока пусть так, для упрощения разработки и использования. В идеале, конечно же, сделать мощный редактор для протягивания связей между элементами, но это не сейчас.

### проводник

Проводниковый элемент. Может иметь заряд и не иметь, 0/1. Становится 1, если рядом есть источники питания, то есть в его клетку направлен какой-либо поток, заряд. Если, скажем, по соседству с ним есть активный проводник. Или какой-нибудь ещё элемент, который способен направлять в каком-то направлени заряд. Такие предметы принадлежат одному типажу? _Те, что способны отдавать заряд_.

### Источник питания

Название говорит само за себя. Как и проводник, может быть помещён в клетку. Состояние - вкл/выкл. Если включён, то отдаёт заряд своим соседям, во все стороны.

### Инвертор

Элемент, помещается в клетку. Имеет направление - север юг запад восток. Вернее, имеет тыл и фронт. С тыловой части вход, с передней выход. Инвертирует поступающий сигнал. Если на входе есть, на выходе нет. И наоборот.

### Лампочка

Элемент, который наглядно показывает наличие сигнала и только это, by design. По сути конечный элемент цепочек, но может быть и просто индикатором любым. Ставится в сетку, может иметь входы со всех сторон

---

В принципе из этого можно собрать и всё остальное. И, ИЛИ, ИЛИ-НЕ и так далее до процессора (ага).

Взаимосвязи между элементами должны быть отображены. То есть проводники должны быть связаны визуально, двойные, тройные, перекрёстки - всё как в майне. Также соединения с источниками питания и с инверторами.

> Для этого нужна какая-то над-система, работающая не с конкретными элементами, а с интерфейсами типа 'вот тут в сетке элемент и в эти клетки у него ноги расти могут'. А далее, когда какой-то элемент хочет себя отрисовать и смотрит, где он стыкуется, он стыкуется с теми элементами, у которых 'ноги растут' к нему.

## как бегают сигналы

Как? Проводник не может быть держателем сигнала, ведь так? В майнкрафте так. Его активность устанавливается другими элементами, удалённостью от них. А я бы хотел, чтобы было видно прямо как бегают сигналы по цепям.

Допустим, есть источник питания и от него проводок к лампочке. Источник питания врубается, и всем соседям сообщается о том, чтобы они становились активными.

```

  #---@


# - источник
*дефис* - провод
@ - лампочка
```

Сначала первый проводник загорается и говорит своим соседям загореться. Потом второй загорается и говорит остальным загореться. И так постепенно доходит до лампочки, она загорается.

Нет. Событиями это всё проводить - убиться об стену. Состояния - вот ключ к простоте. Скажем, надо хранить для каждой ячейки в сетке, какие откуда заряды поступают. Например, если в ячейке `0, 0` есть активный источник питания, то для соседа ячейки этой, например, `1, 0`, есть инфа о том, что сюда идёт заряд из `0, 0`. Когда активность перестанет быть, тогда этой инфы больше не будет.

Для чего я это думаю? Потому что непонятно, как быть со случаями, когда проводники сами могут начать выступать источниками. Если я выключаю источник, то провод должен потухнуть. Не должно быть такого, что провод состоит из двух частей, к одному концу которого подключён источник, после чего источник исчезает, а проводок продолжает питаться от другого конца, к которому ничего не подключено.

Ввести отдельно живущую сущность, 'заряд'? Заряды бегают по разным направлениями. Поступают из одного места, бегут в другие... тогда вообще всё может быть запутанно, если замыкать провода на себя.

Сделать всё же как в майне? Провода активны на расстоянии N-шагов от любого источника питания? Вводить буфферы?

Хочется наблюдать, как это всё волнообразно нарастает. Заряды не могут просто взять и побежать назад, как не может потечь в гору вода. Представлять, будто мои заряды - это вода? И как она будет растекаться по проводниками, инвертироваться и так далее? Вода, допустим, может течь только вниз.

**решение:** сделать всё же как в майне. Провод целиком либо имеет заряд, либо нет. Дальность от источников роли не играет. Провод - это совокупность соединённых проводников-соседей. Как только он становится активным, активными в тот же момент становятся и те элементы, которые он питает.

## UI

Клавиши управления видны всегда. Регулировка скорости сигналов. Клавиши управления меняются в зависимости от элемента, над которым располагаеся мышь.

Есть сетка, её можно передвигать и масштабировать колёсиком (зум не MVP). В клетки можно ставить различные элементы. Для каждого элемента своя кнопка создания. Если в клетке уже есть элемент, то при наведении соответствующие кнопки подсвечиваются.

**Сделать отзывчивым и приятным - одна из главнейших целей.**

-   Зажать кнопку и мышью ведя вся усеивать элементами одного типа, соответствующими нажатой кнопке.
-   Нельзя зажать одновременно несколько "создающих" кнопок. Вернее, зажать можно, но активна будет только первая из них
-   Также с кнопкой удаления. Её можно зажать и вести по всем клеткам, которые надо очистить

## Core

Ядро. Как там оно изнутри работает. Описание алгоритма и принципов работы, до мелочей.

В корне своём, есть некая сетка, на ней разные элементы. В зависимости от положения относительно друг друга они по-разному друг на друга влияют. Эта система работает **циклично**. В каждом цикле обновляется состояние активности.

### первая концепция

Помимо сетки элементов есть сетка активности, наложенная поверх на сетку с элементами. В каждой ячейке хранится информация о том...

Нет, сетка одна и она постоянна. А вот в каждой ячейке есть множество разной инфы. Первая - какой элемент там лежит. Пустой ли или что-то другое. Второе - информация о том, что с какой-то стороны туда поступает "сигнал". Грубо говоря, массив направлений.

**Направления**: север-юг-запад-восток. Хули ещё надо-то.

И вот, допустим, источник питания зажёгся и начинает транслировать сигнал по всем направлениям (ближайшим клеткам-соседям). В следующем цикле те элементы, которые оказались в тех клетках, в которые идёт теперь сигнал, получают инфу об этом и могут уже сами изменить своё поведение. Начать транслировать сигналы куда-то, или прекратить...

Как это сделать декларативно и производительно? Не так, чтобы в каждом цикле опрашивался каждый элемент и чтобы он отдавал своё состояние. Должна быть точечная реакция на изменения.

И ещё важная **проблема**: надо объединять множество соседствующих проводников в одно целое множество. И разъединять в случае, когда соединяющее звено удаляется. Мысли: при добавлении нового смотреть соседей. Если их нет, то у этого нового своё единичное множество. Если рядом есть, то присоединиться к нему. При добавлении относительно просто. А при удалении... Можно применить такой рекурсивный алгоритм. Взять множество, удалить из него удаляемый. Изъять из него первый попавшийся и взять его за начало. Взять второй - сосед... Не, не то. Может, достаточно просто хранить в проводе все соседний элементы для навигации быстрой к ним. А при подключении сигнала к какому-либо из проводов рекурсивно проходить ко всем остальным и фантомно им прописывать, мол, источник сигнала есть вон там-то и там-то. Когда где-то он отключится, он так же рекурсивно отключится и у всех соседних. Ага, тут понятно, а что при добавлении провода по такой схеме? Сначала он интегрируется к своим соседям и перенимает их сигнал, копирует. Или лучше не копирует? Один объект на всех? Ну в общем да, не суть. А если в него ещё откуда-то поступает сигнал, в его ячейку, напрямую, то он ещё и рекурсивно всем прописывает новый источник сигнала (если он есть) (рекурсия не нужна, если на всех один объект с данными об источниках). А вот при удалении... Сначала, если этот проводник является источников сигнала, то он должен себя удалить у остальных. Затем удаляет себя из соседей остальных. А если там проводники были объединены во множества, то они, возможно, должны разъединиться.

Ладно, оставим пока проводники. Энивей надо решать всё это красиво, декларативно. Оперировать данными, состояниями, а не объектами, поведением, которые как-то там они так нах работают непонятно как.

**Похоже, делать ядро в первую очередь я буду всё же на расте.**

### стараюсь определиться с поведением. Чёткое ТЗ.

На сетке могут располагаться четыре типа элементов - источник питания, проводник, инвертор, лампочка. Они работают с сигналами, как-то с ними взаимодействуют. Система из этих элеметнов работает циклично. В одном тике состояния активности могут измениться - могут появиться новые источники сигналов, могут исчезнуть. В следующем цикле происходит реакция на изменения в прошлом.

Источник питания может быть активен и не активен. Если активен, то посылает сигналы в соседние 4 клетки.

Проводник - проводит сигнал. Множество соседних проводников образуют единую группу. Когда сигнал поступает в любой из них, все они загораются и излучают сигнал в соседние клетки (но не в самих себя, разумеется).

Инвертор - инвертирует входящий сигнал в выходящий. Имеет чёткое направление, вход и выход. Если на входе есть сигнал, то на выходе его больше нет. Если на входе ничего - то на выходе сигнал есть.

Лампочка - принимает сигнал со всех направлений. Индикатор того, что в этой точке есть сигнал.

#### Каскад активации

В одном цикле, допустим, активируется источник. Он при этом сообщает о том, что надо активировать соседей. В следующем цикле они активируются.

В одном цикле активируется проводник. В этом же цикле "загорается" и вся остальная часть его соседей. И все они сообщают о том, что надо активировать их соседей. В следующем цикле соседи активируются.

В одном цикле проводник деактивируется. Если к остальным соседям ничего не подключено, то вся группа тухнет. В следующем цикле потухнет и то, что является к этим проводникам соседями.

В одном цикле загорается проводник. К нему подключена лампочка. В следующем цикле она тоже станет активной, то бишь загорится.

Есть инвертор и два проводника, на входе и на выходе. Ко входу ставится источник. Источник запускают. В первом цикле он просто горит. Далее загорается провод. Далее инвертор меняет полярность. Далее провод на выходе тухнет.

```
Источник слева, далее провод, далее лампочка. Включение источника.

0----.
1----.
1====.
1====*

Схема с инвертором. Выключение источника

1==!>0--.
0==!>0--.
0--!>0--.
0--!>1--.
0--!>1==.
0--!>1==*
```

**Цикличность.** Думаю, стоит сделать не один цикл обновления на всех разом, а более событийно, но, однако же, с фиксированным интервалом. Допустим, есть источник. Его отключают - он через какое-то время сообщает об этом остальным. Провод отключается - через какое-то время сообщает остальным. И так далее. В этом случае, правда, уже не так просто это делать будет на расте, скорее на js.

## Наброски

Надо пробовать описывать интерфейс того, как с этим работать извне. Может, станет понятно, как это элегантно реализовать внутренне. Или же стоит сначала реализовать хоть как-то?

```ts
interface Element {}

interface System {
    mountElement: (x: number, y: number, elem: Element) => void;
    removeElement: (x: number, y: number) => void;
}

const system = new System();
```

Элементы не должны знать, в какой точке они находятся. Всю инфу об окружении они получают извне. Как? "Окружение" предоставляет ему какие-то методы для извлечения информации?

```rs
enum Direction {
  Up,
  Down,
  Left,
  Right
}

struct SignalInfo {
  from: Direction
}

trait Environment {
  fn what_is_there(dx: i32, dy: i32) -> ;

  fn signals_at_my_place() -> &Vec<SignalInfo>;
}

struct EnergySource {};

impl EnergySource {
  fn update<T>(&mut self, env: &T) where T: Environment;
}
```

### Модель акторов?

Какие тут могут быть акторы?

-   Сетка с элементами
-   Каждый элемент - источник, провод, лампочка, инвертор etc

Сетка. Какое у неё состояние? Её элементы, знание об элементах.

Источник питания. Состояние - вкл выкл. Не принимает никакие сообщения, только отсылает на сетку, что он направляет туда-то и туда-то сигналы.

Проводок. Принимает сообщения о том, что где-то активно или неактивно. Передаёт соседям, что он их питает,
